<link rel="import" href="joi-comparator.html">

<dom-module id="game-judge">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <slot on-tick="_countTick" on-key-down="_onKeyDown" on-key-up="_onKeyUp" on-key-stroke="_onKeyStroke"
          on-key-pause-end="_onKeyPause" on-joievent="_holdEvents"></slot>

    <joi-comparator array-one="[[joiOne]]" array-two="[[keyLog]]"></joi-comparator>
      
  </template>

  <script>
    class GameJudge extends Polymer.Element {
      static get is() {
        return "game-judge";
      }

      static get config() {
        return {
          properties: {
            input: {
              type: String,
              observer: "_inputChange"
            },
            joiOne: {
              type: Array,
              value: function() {
                return []
              }
            },
            ticksPerTurn: {
              type: Number,
              value: 10
            },
            heldEvents: {
              type: Object,
              value: function () {
                return {};
              }
            },
            registerEvents: {
              type: Array,
              value: function () {
                return [];
              }
            },
            keys: {
              type: Array,
              value: function () {
                return [];
              }
            },
            keyLog: {
              type: Array,
              value: function() {
                return []
              }
            },
            chordMode: {
              type: Boolean,
              value: false
            },
            scale: Object
          }
        }
      }

      _inputChange() {
        const joi = {};
        joi["id0"] = JOI.parse(this.input);
        this.joiOne = joi["id0"];
        this.querySelector("joievent-player").setScenario(joi["id0"]);
        this.querySelector("#scenario").scenario = joi["id0"];
      }

      _holdEvents(e) {
        e.stopPropagation();
        e.preventDefault();
        let eid = e.detail.id;
        if (this.registerEvents[eid])
          return;
        this.registerEvents[eid] = true;
        if (e.detail.duration) { //duration exists and is not 0
          this.heldEvents[eid] = {
            ticksLeft: e.detail.duration * this.ticksPerTurn,
            event: e
          };
        }
      }

      _countTick(e) {
        for (let hostage in this.heldEvents) {
          let evt = this.heldEvents[hostage];
          evt.ticksLeft--;
          if (evt.ticksLeft <= 0) {
            this.querySelector("joievent-player").releaseNextEvent(evt.event);
            delete this.heldEvents[hostage];
          }
        }
      }

      _onKeyPause(e){
//        this.querySelector("#audioPlayer").playKeys(e.detail.code, e.detail.heldKeys);
//        this.querySelector("#keyboard").highlightKeys(e.detail.code);
      }

      _onKeyDown(e){
        var bground = this.querySelector("#bground");
        bground.animate();
        var keyboard = this.querySelector("#keyboard");
        var node = keyboard.querySelector("key-visual[code='"+e.detail.code+"']");

        if (this._checkForCommands(e.detail.code))
          return;

        let sharp = this._addSharpen(e.detail.heldKeys);

        var tone, octave;
        if (node) {
          tone = Number(node.tone);
          octave = Number(node.octave);
        }
        
        if (!tone && tone != 0) return;

        if (this.chordMode){
          let codes = this.scale.getChord(tone);//querySelector("#clef").getChord(tone, octave);
          for (let tone of codes) {
            var code = this.scale.getToneNumber(tone, octave);
//            var code = this.querySelector("#clef").getTone(tone, octave);
            this.querySelector("#audioPlayer").playTone(code);
          }
          return;
        }

        let trueTone = this.scale.getToneNumber(tone, octave) + sharp;
//        let trueTone = this.querySelector("#clef").getTone(tone, octave) + sharp;
        this.querySelector("#audioPlayer").playTone(trueTone);
        keyboard.highlightKeys(e.detail.code);
      }

      _onKeyUp(e){
        //stopSoundBeingPlayed
        this.querySelector("#keyboard").unhighlightKeys(e.detail.code);
      }

      _onKeyStroke(e){
        this.keyLog.push(e.detail);
        this.notifyPath("keyLog");
        // console.log(e.detail.code + ", " + Math.round(e.detail.duration*100)/100);
        //if the key stroke is correct, then create a beam
        if (this._checkIfHeldKeysMatchesWhatYouAreHopingFor(e))
          this.querySelector("#beams").prepareBeam(e.detail.code);

        //if it is wrong, make baaaaad beam
        //if wrong, make ugly sound
        if(this._checkIfOutsideScope(e.detail.pressedKey))
          0+0;//.querySelector("#audioPlayer").playFailure();
      }

      _checkForCommands(code) {
        switch (code) {
          case "Tab":
            this.querySelector("#clef").turnKeyLeft();
            return true;
          case "Enter":
            this.querySelector("#clef").turnKeyRight();
            return true;
          case "Backquote":
            this.querySelector("#clef").turnModusLeft();
            return true;
          case "Backspace":
            this.querySelector("#clef").turnModusRight();
            return true;
        }
        return false;
      }

      _addSharpen(arrayOfKeys) {
        for (let code of arrayOfKeys) {
          if (code && code == "ShiftLeft")
            return 1;
        }
        return 0;
      }

//      _recordPlayedKeys (e) {
//        console.log(e.detail.pressedKey + ", " + new Date().getTime());
//      }
//
//      _registerKeys(e) {
//        this._recordPlayedKeys(e);
//        //the audio
//        //all events coming in are played as music. key down and up starts and stops the sound
//        if (e.detail.pressedKey)
//          this.querySelector("#audioPlayer").playKeys(e.detail.pressedKey, e.detail.heldKeys);
//
//        //the error
//        //the outside scope error sound is played in addition to the key which is struck.
////        if(this._checkIfOutsideScope(e.detail.pressedKey))
////          this.querySelector("#audioPlayer").playFailure();
//
//        //the success
//        //and the beam are passed whenever a correct sound is played.
//        if (this._checkIfHeldKeysMatchesWhatYouAreHopingFor(e.detail.heldKeys))
//          this.querySelector("#beams").prepareBeam(e.detail.heldKeys);
//      }


      _checkIfOutsideScope(keyPressed) {
        for (let hostage in this.heldEvents) {
          let waitingFor = "Key" + this.heldEvents[hostage].event.detail.letter;
          if (waitingFor == keyPressed)
            return false;
        }
        return true;
      }

      _checkIfHeldKeysMatchesWhatYouAreHopingFor(heldKeys) {
        for (let i in this.heldEvents)
          if (this.heldEvents[i].event.detail.letter == heldKeys.detail.code.replace("Key", ""))
            return true;

        return false;
      }
//      _checkIfHeldKeysMatchesWhatYouAreHopingFor(heldKeys) {
//        let heldArray = [];
//        for (let i in this.heldEvents)
//          heldArray.push("Key" + this.heldEvents[i].event.detail.letter);
//
//        return heldKeys.sort().toString() == heldArray.sort().toString();
//      }
    }
    customElements.define(GameJudge.is, GameJudge);
  </script>
</dom-module>